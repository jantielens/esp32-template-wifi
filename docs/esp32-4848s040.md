# ESP32-4848S040 Display Support (ST7701 RGB)

This document explains how support for the Guition ESP32-S3-4848S040 board display was implemented, the key decisions, the issues encountered, and the remaining tuning options. It is intended to let another agent re-implement the work from scratch.

## Hardware Summary
- Board: Guition ESP32-S3-4848S040
- MCU: ESP32-S3, 16 MB flash, 8 MB OPI PSRAM
- Display: 480×480 ST7701 RGB (parallel RGB, 16-bit RGB565)
- Control interface: 9-bit SPI for ST7701 init commands (CS=39, SCK=48, MOSI=47)
- RGB pins: 5R + 6G + 5B, DE, HSYNC, VSYNC, PCLK
- Timing: PCLK=8 MHz, HSYNC 10/8/50, VSYNC 10/8/20, pclk_active_neg=0
- Touch: GT911 capacitive (I2C via Wire1, SDA=19, SCL=45, addr=0x5D/0x14)
- FQBN: esp32:esp32:esp32s3:FlashSize=16M,PSRAM=opi,PartitionScheme=app3M_fat9M_16MB,CDCOnBoot=default

## Reference Sources
- Sample project: sample/ESP32-4848S040/src/4.0_LvglWidgets.ino
- Sample project (non-LVGL): sample/esp32-4848s040-st7701/src/display.cpp
- Arduino_GFX issue: https://github.com/moononournation/Arduino_GFX/issues/684

## Implementation Overview

### Architecture

The driver delegates all panel management to the Arduino_GFX library stack:

```
Arduino_SWSPI (9-bit SPI, ST7701 init commands)
  → Arduino_ESP32RGBPanel (RGB parallel bus, timing, bounce buffer)
    → Arduino_RGB_Display (framebuffer management, auto_flush)
```

LVGL renders into its own draw buffers (allocated in PSRAM), then flushes
partial updates via `draw16bitRGBBitmap()` — the standard Arduino_GFX
drawing path. Arduino_GFX copies pixels to its PSRAM framebuffer and calls
`Cache_WriteBack_Addr` automatically (auto_flush=true).

### 1) Board Overrides
File: src/boards/esp32-4848S040/board_overrides.h
- Sets display geometry (480×480) and all pin definitions for RGB + SPI init.
- Enables display and touch.
- LVGL buffer configuration:
  - LVGL_BUFFER_SIZE = DISPLAY_WIDTH × 20 (20-line partial updates)
  - LVGL_BUFFER_PREFER_INTERNAL = false (PSRAM, saves ~19 KB internal SRAM)
- LVGL_TASK_CORE = 1 (pins render task to Core 1, away from WiFi on Core 0)

### 2) Display Driver
Files:
- src/app/drivers/st7701_rgb_driver.h
- src/app/drivers/st7701_rgb_driver.cpp

Key configuration:
- **PCLK**: 8 MHz (prefer_speed=8000000L) — lowered from 12 MHz default to reduce PSRAM bandwidth pressure
- **Bounce buffer**: Disabled (ST7701_BOUNCE_BUFFER_LINES=0) — stable without it at 8 MHz PCLK. Code is retained and can be re-enabled by setting to 40 (~75 KB internal SRAM cost) if flickering reappears.
- **auto_flush**: true (Cache_WriteBack_Addr after each draw16bitRGBBitmap)
- **bb_invalidate_cache**: false (not needed with auto_flush)
- **Single framebuffer**: Arduino_GFX default (num_fbs=1)

The driver implements the DisplayDriver HAL:
- `init()` creates the Arduino_GFX stack (bus → rgbpanel → gfx), runs ST7701 init sequence, enables backlight
- `setAddrWindow()` / `pushColors()` delegates to `gfx->draw16bitRGBBitmap()`
- Standard backlight on/off via GPIO38

### 3) Touch Driver
Files:
- src/app/drivers/gt911_touch_driver.h
- src/app/drivers/gt911_touch_driver.cpp

Key design decisions:
- **Vendored driver** (no external library) — the TAMC_GT911 library caused interrupt watchdog crashes because it uses Wire (I2C bus 0), whose ISR is pinned to Core 0. When LVGL polls touch from Core 1, the I2C access crosses cores and deadlocks with WiFi on Core 0.
- **Wire1 (I2C bus 1)** — initializing Wire1.begin() from the LVGL task pins its ISR to Core 1, keeping all I2C traffic off Core 0.
- **Auto-probes address** — tries 0x5D first, falls back to 0x14 (GT911 address depends on INT pin strapping).
- **No reset sequence** — RST and INT pins are not connected on this board; GT911 boots into normal mode by default.
- **Minimal register access** — reads GT911_POINT_INFO (0x814E) and first touch point (0x814F), clears buffer status after each read.

### 4) Touch Test Screen
Files:
- src/app/screens/touch_test_screen.h
- src/app/screens/touch_test_screen.cpp

- Full-screen LVGL canvas for finger-painting (verifies touch input visually).
- Red dots at actual hardware touch points, white connecting lines for continuity.
- Resolution-independent brush sizing (~0.8% of smaller display dimension, clamped 2-6px).
- PSRAM-deferred: canvas buffer (~450 KB for 480×480) allocated on show(), freed on hide(). Zero PSRAM cost when inactive.
- Navigation via web portal only (`/api/display/screen` with `"touch_test"`).
- Gated by `HAS_TOUCH` at compile time.

### 5) LVGL Integration
File: src/app/display_manager.cpp
- LVGL draw buffers allocated in PSRAM (LVGL_BUFFER_PREFER_INTERNAL=false)
- Standard flush path: setAddrWindow → pushColors (no direct mode, no double-buffer swap)
- LVGL render task uses PSRAM-backed stack (saves 8 KB internal SRAM)
- Render task pinned to Core 1 via LVGL_TASK_CORE

### 6) Memory Optimizations
- LVGL draw buffer in PSRAM: saves ~19 KB internal SRAM
- LVGL task stack in PSRAM: saves ~8 KB internal SRAM (via rtos_create_task_psram_stack_pinned)
- fw_update task stack in PSRAM: saves ~12 KB when OTA is active (via rtos_create_task_psram_stack)
- Bounce buffer disabled: saves ~75 KB internal SRAM (was the largest consumer)
- Total internal SRAM savings: ~27 KB permanent + 75 KB from bounce buffer removal

## Key Decisions

1) **Delegate to Arduino_GFX entirely**
   - Earlier attempts used ESP-IDF rgb_panel directly with double framebuffers and VSYNC-gated swaps. This was complex, fragile, and still flickered.
   - The working approach uses Arduino_GFX's own Arduino_RGB_Display which manages the ESP-IDF panel internally. This matches proven sample code.
   - LVGL uses the standard setAddrWindow/pushColors flush path — simple and reliable.

2) **8 MHz PCLK (down from 12 MHz)**
   - Lower pixel clock reduces PSRAM bandwidth pressure from LCD DMA.
   - Combined with bounce buffer removal, this eliminated all flickering.
   - Refresh rate is lower (~28 Hz vs ~42 Hz) but sufficient for UI rendering.

3) **Bounce buffer disabled**
   - With 8 MHz PCLK, DMA directly from PSRAM framebuffer is stable.
   - Saves ~75 KB of precious internal SRAM.
   - Code retained with clear re-enable instructions (set ST7701_BOUNCE_BUFFER_LINES=40).

4) **Single framebuffer (not double)**
   - Arduino_GFX uses single framebuffer by default.
   - LVGL partial updates (20 lines) are small enough that tearing is not visible.
   - Saves ~450 KB PSRAM vs double framebuffer.

5) **LVGL buffers and task stacks in PSRAM**
   - Internal SRAM is scarce on this board due to RGB panel DMA requirements.
   - PSRAM is abundant (8 MB, ~7.5 MB free after all allocations).
   - Moved LVGL draw buffer (~19 KB) and task stack (8 KB) to PSRAM.

## Issues Encountered and Resolutions

### Phase 1: ESP-IDF Direct Panel (Attempts 1-5) — All Had Flickering

1) **Flickering (left/right horizontal shifts)**
   - Cause: Updating a single PSRAM framebuffer while RGB DMA scans it.
   - Attempted fix: ESP-IDF RGB panel with double framebuffer (num_fbs=2, double_fb=true).
   - Result: Reduced but did not eliminate flickering.

2) **Random pixels / worse flicker when removing cache flush**
   - Cause: Manual memcpy from LVGL buffer to framebuffer without cache sync.
   - Fix: Used esp_lcd_panel_draw_bitmap (handles cache internally).

3) **Crashes / "no free rgb panel slot"**
   - Cause: Creating multiple RGB panels (Arduino_RGB_Display begin() + manual getFrameBuffer).
   - Fix: Used a single panel instance.

4) **Severe memory pressure (~5 KB free)**
   - Cause: LVGL double-buffered full-screen buffers in internal RAM.
   - Fix: Moved LVGL buffers to PSRAM.

5) **Flicker changing shape (vertical shifts, black gaps)**
   - Cause: refresh_on_demand mode with irregular flush timing.
   - Fix: Switched to continuous refresh.

6) **Persistent periodic flicker with WiFi active**
   - Cause: Even with bounce buffers and double framebuffers, ESP-IDF direct panel approach couldn't fully isolate DMA from PSRAM contention.
   - Fix: Abandoned ESP-IDF direct approach entirely (see Phase 2).

### Phase 2: Arduino_GFX Delegation (Attempt 6) — Resolved

7) **Initial Arduino_GFX attempt still flickered**
   - Cause: Bounce buffer too small (10 lines) and PCLK too high (12 MHz GFX_NOT_DEFINED default).
   - Fix: Increased bounce buffer to 40 lines and lowered PCLK to 8 MHz.

8) **Bounce buffer consuming ~75 KB internal SRAM**
   - Investigation: Tested with bounce buffer disabled (0 lines) at 8 MHz PCLK.
   - Result: Display remained stable — bounce buffer unnecessary at lower PCLK.
   - Fix: Disabled bounce buffer, kept code in place for easy re-enable.

## Current State (as of Feb 10, 2026)

- **Display: Stable** — no flickering with WiFi active, OTA updates, image uploads
- **Internal heap free: ~200 KB** (up from ~100 KB before optimizations)
- **PSRAM free: ~7.5 MB** (of 8 MB total)
- **Architecture: Simple** — Arduino_GFX handles all panel management, LVGL uses standard flush path
- **Configuration: Minimal** — 8 MHz PCLK, no bounce buffer, single framebuffer, auto_flush
- LVGL task pinned to Core 1 (WiFi on Core 0)
- LVGL draw buffer and task stack in PSRAM

Boot log metrics:
```
boot: hf=295896 hi=295896 pf=8381372
setup: hf=~200000 hi=~200000 pf=7879004
```

## Tuning Guide

### If flickering reappears
1. **Re-enable bounce buffer**: Set `ST7701_BOUNCE_BUFFER_LINES 40` in st7701_rgb_driver.cpp (~75 KB internal SRAM cost)
2. **Lower PCLK further**: Change `prefer_speed` from `8000000L` to `6000000L` (lower refresh rate)
3. **Increase LVGL buffer**: Larger partial updates = fewer flush calls = less PSRAM traffic
4. **Pin WiFi to Core 0**: Already done via LVGL_TASK_CORE=1

### If memory is tight
1. **Reduce LVGL buffer**: Change `LVGL_BUFFER_SIZE` from `DISPLAY_WIDTH * 20` to `DISPLAY_WIDTH * 10`
2. **Ensure PSRAM allocation**: Verify `LVGL_BUFFER_PREFER_INTERNAL false` in board_overrides.h
3. **Check AsyncTCP stack**: Watermark showed 15592/16384 used — could potentially reduce

### If refresh rate is too low
1. **Increase PCLK**: Change `prefer_speed` from `8000000L` to `12000000L` (may need bounce buffer)
2. **Increase LVGL buffer size**: More lines per flush = fewer total flushes

## Changed Files (for full re-implementation)

Display + board bring-up:
- config.sh (FQBN target for esp32-4848S040)
- src/boards/esp32-4848S040/board_overrides.h (pins, timings, LVGL config)
- src/app/board_config.h (DISPLAY_DRIVER_ST7701_RGB and TOUCH_DRIVER_GT911 enums)
- src/app/display_drivers.cpp (driver include)
- src/app/display_manager.cpp (PSRAM-backed LVGL task, standard flush path)
- src/app/display_manager.h (PSRAM task alloc member, TouchTestScreen)
- src/app/drivers/st7701_rgb_driver.h
- src/app/drivers/st7701_rgb_driver.cpp

Touch:
- src/app/drivers/gt911_touch_driver.h
- src/app/drivers/gt911_touch_driver.cpp
- src/app/touch_drivers.cpp (GT911 include)
- src/app/touch_manager.cpp (GT911 instantiation)
- src/app/screens/touch_test_screen.h
- src/app/screens/touch_test_screen.cpp
- src/app/screens.cpp (touch_test_screen include)
- src/app/lv_conf.h (LV_USE_CANVAS enabled when HAS_TOUCH)

Memory optimization:
- src/app/rtos_task_utils.h (PSRAM task creation utilities)
- src/app/rtos_task_utils.cpp (pinned + unpinned variants)
- src/app/web_portal_firmware.cpp (fw_update task PSRAM stack)

Support + docs:
- src/app/drivers/README.md (board table entry)
- docs/compile-time-flags.md (auto-generated)
- docs/esp32-4848s040.md (this doc)

## Notes on Arduino_GFX Issue #684
- The issue documents that v1.6.0+ replaced Arduino_ST7701_RGBPanel with Arduino_RGB_Display.
- The sample code in #684 uses Arduino_RGB_Display with auto_flush for direct drawing.
- Our LVGL integration works because draw16bitRGBBitmap() is a standard Arduino_GFX drawing method that triggers auto_flush cache writeback.
