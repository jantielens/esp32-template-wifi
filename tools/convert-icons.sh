#!/usr/bin/env bash
#
# convert-icons.sh - Convert PNG icons to LVGL C arrays
#
# This script converts PNG icons in ui-assets/icons/ to LVGL image C arrays
# using the LVGL online image converter API.
#

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
ICONS_DIR="$PROJECT_ROOT/ui-assets/icons"
OUTPUT_DIR="$PROJECT_ROOT/src/app/ui"
OUTPUT_FILE="$OUTPUT_DIR/icons.h"

# LVGL image converter settings
# Note: Using RGB565A8 (CF_TRUE_COLOR_ALPHA) for memory efficiency
# If you see artifacts, Material Icons may not be perfectly centered in their canvas
COLOR_FORMAT="CF_TRUE_COLOR_ALPHA"  # RGB565A8 with alpha
OUTPUT_FORMAT="C_ARRAY"

echo "=== LVGL Icon Converter ==="
echo "Icons directory: $ICONS_DIR"
echo "Output file:     $OUTPUT_FILE"
echo ""

# Create output directory
mkdir -p "$OUTPUT_DIR"

# Check if icons exist
if [ ! -d "$ICONS_DIR" ]; then
  echo "Error: Icons directory not found: $ICONS_DIR"
  exit 1
fi

# Count icon files (PNG and SVG)
PNG_COUNT=$(find "$ICONS_DIR" -maxdepth 1 -name "*.png" | wc -l)
SVG_COUNT=$(find "$ICONS_DIR" -maxdepth 1 -name "*.svg" | wc -l)
TOTAL_COUNT=$((PNG_COUNT + SVG_COUNT))

if [ "$TOTAL_COUNT" -eq 0 ]; then
  echo "Error: No PNG or SVG files found in $ICONS_DIR"
  exit 1
fi

echo "Found $PNG_COUNT PNG and $SVG_COUNT SVG icon(s)"
echo ""

# Check for Python and required modules
if ! command -v python3 &> /dev/null; then
  echo "Error: python3 not found. Please install Python 3."
  exit 1
fi

# Check for PIL (Pillow)
if ! python3 -c "import PIL" 2>/dev/null; then
  echo "Installing Python Pillow for image processing..."
  python3 -m pip install --user Pillow 2>/dev/null || {
    echo "Error: Failed to install Pillow. Please install manually: pip install Pillow"
    exit 1
  }
fi

# Check for cairosvg (for SVG support)
if ! python3 -c "import cairosvg" 2>/dev/null; then
  echo "Installing cairosvg for SVG support..."
  python3 -m pip install --user cairosvg 2>/dev/null || {
    echo "Warning: Failed to install cairosvg. SVG files will be skipped."
  }
fi

# Start generating the header file
cat > "$OUTPUT_FILE" << 'HEADER_START'
/**
 * @file icons.h
 * @brief LVGL image arrays for UI icons
 * 
 * Auto-generated by tools/convert-icons.sh
 * Do not edit manually.
 */

#ifndef UI_ICONS_H
#define UI_ICONS_H

#ifdef __cplusplus
extern "C" {
#endif

#include <lvgl.h>

HEADER_START

# Python script to convert PNG/SVG to C array
CONVERTER_SCRIPT=$(cat << 'PYTHON_SCRIPT'
import sys
from PIL import Image
import os
import io

# Try to import cairosvg for SVG support
try:
    import cairosvg
    HAS_SVG_SUPPORT = True
except ImportError:
    HAS_SVG_SUPPORT = False

def load_image(file_path, target_size=None):
    """Load image from PNG or SVG file"""
    if file_path.lower().endswith('.svg'):
        if not HAS_SVG_SUPPORT:
            print(f"Error: cairosvg not available, skipping SVG: {file_path}", file=sys.stderr)
            return None
        
        # Render SVG to PNG in memory with no anti-aliasing
        if target_size:
            width, height = target_size
        else:
            # Default size if not specified
            width = height = 48
        
        png_data = cairosvg.svg2png(
            url=file_path,
            output_width=width,
            output_height=height,
        )
        img = Image.open(io.BytesIO(png_data)).convert('RGBA')
        return img
    else:
        # Load PNG normally
        return Image.open(file_path).convert('RGBA')

def convert_icon_to_c_array(icon_path, var_name):
    """Convert PNG/SVG to LVGL C array format (RGB565A8)"""
    # Load image to get actual dimensions (default 48x48 for SVG if no size specified)
    filename = os.path.basename(icon_path)
    if filename.lower().endswith('.svg'):
        # For SVG, check filename hint or use default
        if '_64dp' in filename.lower():
            target_size = (64, 64)
        else:
            target_size = (48, 48)
    else:
        # For PNG, load to detect size
        target_size = None
    
    original_img = load_image(icon_path, target_size)
    if original_img is None:
        return
    img = original_img
    
    # Auto-center the icon content within the canvas
    bbox = img.getbbox()
    was_centered = True
    if bbox:
        left, top, right, bottom = bbox
        content_width = right - left
        content_height = bottom - top
        content_center_x = left + content_width // 2
        content_center_y = top + content_height // 2
        img_center_x = img.size[0] // 2
        img_center_y = img.size[1] // 2
        offset_x = content_center_x - img_center_x
        offset_y = content_center_y - img_center_y
        
        # Check if re-centering is needed
        if offset_x != 0 or offset_y != 0:
            was_centered = False
            print(f"  ⚠️  Content offset detected: ({offset_x:+d}, {offset_y:+d}) pixels - auto-centering...", file=sys.stderr)
            # Crop to content
            content = img.crop(bbox)
            # Create new centered image
            img = Image.new('RGBA', img.size, (0, 0, 0, 0))
            # Calculate centering offset
            left = (img.size[0] - content.size[0]) // 2
            top = (img.size[1] - content.size[1]) // 2
            # Paste centered content
            img.paste(content, (left, top))
    
    width, height = img.size
    
    # Apply alpha threshold to eliminate semi-transparent edge artifacts
    # Material Design icons have anti-aliasing that doesn't convert well to RGB565
    pixels_array = img.load()
    for y in range(height):
        for x in range(width):
            r, g, b, a = pixels_array[x, y]
            # Threshold: pixels with alpha < 128 become fully transparent
            # This eliminates semi-transparent edge pixels that cause RGB565 artifacts
            if a < 128:
                pixels_array[x, y] = (0, 0, 0, 0)
            elif a < 255:
                # Boost partially transparent pixels to fully opaque
                pixels_array[x, y] = (r, g, b, 255)
    
    pixels = list(img.getdata())
    
    # Generate C array
    print(f"\n/* {var_name} - {width}x{height} */")
    print(f"const LV_ATTRIBUTE_MEM_ALIGN LV_ATTRIBUTE_LARGE_CONST")
    print(f"uint8_t {var_name}_map[] = {{")
    
    # NOTE: For CF_TRUE_COLOR_ALPHA in LVGL 8.3, NO header in data array
    # The header info is in the lv_img_dsc_t structure instead
    
    # Pixel data: RGB565 + A8
    byte_count = 0
    for y in range(height):
        for x in range(width):
            r, g, b, a = pixels[y * width + x]
            
            # Convert RGB888 to RGB565
            r5 = (r >> 3) & 0x1F
            g6 = (g >> 2) & 0x3F
            b5 = (b >> 3) & 0x1F
            rgb565 = (r5 << 11) | (g6 << 5) | b5
            
            # Output RGB565 (little-endian) + Alpha
            if byte_count % 12 == 0:
                print("  ", end="")
            
            print(f"0x{rgb565 & 0xFF:02x}, 0x{(rgb565 >> 8) & 0xFF:02x}, 0x{a:02x}, ", end="")
            byte_count += 3
            
            if byte_count % 12 == 0:
                print()
    
    if byte_count % 12 != 0:
        print()
    
    print("};")
    print()
    
    # Calculate total data size: width * height * 3 bytes per pixel (RGB565A8)
    total_data_size = width * height * 3
    
    print(f"const lv_img_dsc_t {var_name} = {{")
    print(f"  {{")
    print(f"    LV_IMG_CF_TRUE_COLOR_ALPHA,")
    print(f"    0,")
    print(f"    0,")
    print(f"    {width},")
    print(f"    {height}")
    print(f"  }},")
    print(f"  {total_data_size},")
    print(f"  {var_name}_map,")
    print("};")

if __name__ == "__main__":
    convert_icon_to_c_array(sys.argv[1], sys.argv[2])
PYTHON_SCRIPT
)

# Convert each icon file (PNG and SVG)
# Track processed base names to avoid duplicates (PNG takes precedence over SVG)
declare -A processed_names

for icon_file in "$ICONS_DIR"/*.{png,svg}; do
  if [ -f "$icon_file" ]; then
    filename=$(basename "$icon_file")
    filename_noext="${filename%.*}"
    extension="${filename##*.}"
    
    # Skip if we've already processed this base name
    if [ "${processed_names[$filename_noext]}" = "1" ]; then
      echo "Skipping: $filename (already processed as PNG)"
      continue
    fi
    
    # Mark this base name as processed
    processed_names[$filename_noext]=1
    
    # Create a clean variable name
    var_name=$(echo "$filename_noext" | sed 's/[^a-zA-Z0-9_]/_/g' | tr '[:upper:]' '[:lower:]')
    var_name="icon_${var_name}"
    
    echo "Converting: $filename_noext -> $var_name"
    
    # Run Python converter and append to header
    python3 -c "$CONVERTER_SCRIPT" "$icon_file" "$var_name" >> "$OUTPUT_FILE"
  fi
done

# Close the header file
cat >> "$OUTPUT_FILE" << 'HEADER_END'

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* UI_ICONS_H */
HEADER_END

echo ""
echo "✓ Successfully generated $OUTPUT_FILE"
echo ""
